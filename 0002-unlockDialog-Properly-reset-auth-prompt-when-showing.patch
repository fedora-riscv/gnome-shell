From ceee53aa0a40f3bf81945fabb4ecdd70d11143a4 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Tue, 5 Oct 2021 11:01:19 -0400
Subject: [PATCH 2/2] unlockDialog: Properly reset auth prompt when showing it

If a user hits escape twice really fast when coming back to
their machine to unlock it, they made end up getting presented
with a non-functional unlock screen that doesn't show their
user icon and doesn't ask for a password.

This is because showPrompt assumes that if an auth prompt already
exists, it's ready to go. That may not be true, if it's in the
process of getting torn down at the time because it's in the middle
of a cancel animation.

This commit solves the problem by ensuring the auth prompt is always
in a fresh reset state before showing it.

Part-of: <https://gitlab.gnome.org/GNOME/gnome-shell/-/merge_requests/1999>
---
 js/ui/unlockDialog.js | 18 ++++++++----------
 1 file changed, 8 insertions(+), 10 deletions(-)

diff --git a/js/ui/unlockDialog.js b/js/ui/unlockDialog.js
index f4c76c41a..3ef6aa90f 100644
--- a/js/ui/unlockDialog.js
+++ b/js/ui/unlockDialog.js
@@ -649,70 +649,68 @@ var UnlockDialog = GObject.registerClass({
     }
 
     _updateBackgroundEffects() {
         const themeContext = St.ThemeContext.get_for_stage(global.stage);
 
         for (const widget of this._backgroundGroup) {
             const effect = widget.get_effect('blur');
 
             if (effect) {
                 effect.set({
                     brightness: BLUR_BRIGHTNESS,
                     sigma: BLUR_SIGMA * themeContext.scale_factor,
                 });
             }
         }
     }
 
     _updateBackgrounds() {
         for (let i = 0; i < this._bgManagers.length; i++)
             this._bgManagers[i].destroy();
 
         this._bgManagers = [];
         this._backgroundGroup.destroy_all_children();
 
         for (let i = 0; i < Main.layoutManager.monitors.length; i++)
             this._createBackground(i);
         this._updateBackgroundEffects();
     }
 
     _ensureAuthPrompt() {
-        if (this._authPrompt)
-            return;
-
-        this._authPrompt = new AuthPrompt.AuthPrompt(this._gdmClient,
-            AuthPrompt.AuthPromptMode.UNLOCK_ONLY);
-        this._authPrompt.connect('failed', this._fail.bind(this));
-        this._authPrompt.connect('cancelled', this._fail.bind(this));
-        this._authPrompt.connect('reset', this._onReset.bind(this));
-
-        this._promptBox.add_child(this._authPrompt);
+        if (!this._authPrompt) {
+            this._authPrompt = new AuthPrompt.AuthPrompt(this._gdmClient,
+                AuthPrompt.AuthPromptMode.UNLOCK_ONLY);
+            this._authPrompt.connect('failed', this._fail.bind(this));
+            this._authPrompt.connect('cancelled', this._fail.bind(this));
+            this._authPrompt.connect('reset', this._onReset.bind(this));
+            this._promptBox.add_child(this._authPrompt);
+        }
 
         this._authPrompt.reset();
         this._authPrompt.updateSensitivity(true);
     }
 
     _maybeDestroyAuthPrompt() {
         let focus = global.stage.key_focus;
         if (focus === null ||
             (this._authPrompt && this._authPrompt.contains(focus)) ||
             (this._otherUserButton && focus === this._otherUserButton))
             this.grab_key_focus();
 
         if (this._authPrompt) {
             this._authPrompt.destroy();
             this._authPrompt = null;
         }
     }
 
     _showClock() {
         if (this._activePage === this._clock)
             return;
 
         this._activePage = this._clock;
 
         this._adjustment.ease(0, {
             duration: CROSSFADE_TIME,
             mode: Clutter.AnimationMode.EASE_OUT_QUAD,
             onComplete: () => this._maybeDestroyAuthPrompt(),
         });
     }
-- 
2.32.0

