From e45d8817b4fc5fed35d3b39612f7993351b7c92c Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Tue, 5 Oct 2021 11:01:19 -0400
Subject: [PATCH 2/2] unlockDialog: Properly reset auth prompt when showing it

If a user hits escape twice really fast when coming back to
their machine to unlock it, they made end up getting presented
with a non-functional unlock screen that doesn't show their
user icon and doesn't ask for a password.

This is because showPrompt assumes that if an auth prompt already
exists, it's ready to go. That may not be true, if it's in the
process of getting torn down at the time because it's in the middle
of a cancel animation.

This commit solves the problem by ensuring the auth prompt is always
in a fresh reset state before showing it.
---
 js/ui/unlockDialog.js | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/js/ui/unlockDialog.js b/js/ui/unlockDialog.js
index f4c76c41a..3e80c002a 100644
--- a/js/ui/unlockDialog.js
+++ b/js/ui/unlockDialog.js
@@ -649,73 +649,73 @@ var UnlockDialog = GObject.registerClass({
     }
 
     _updateBackgroundEffects() {
         const themeContext = St.ThemeContext.get_for_stage(global.stage);
 
         for (const widget of this._backgroundGroup) {
             const effect = widget.get_effect('blur');
 
             if (effect) {
                 effect.set({
                     brightness: BLUR_BRIGHTNESS,
                     sigma: BLUR_SIGMA * themeContext.scale_factor,
                 });
             }
         }
     }
 
     _updateBackgrounds() {
         for (let i = 0; i < this._bgManagers.length; i++)
             this._bgManagers[i].destroy();
 
         this._bgManagers = [];
         this._backgroundGroup.destroy_all_children();
 
         for (let i = 0; i < Main.layoutManager.monitors.length; i++)
             this._createBackground(i);
         this._updateBackgroundEffects();
     }
 
     _ensureAuthPrompt() {
-        if (this._authPrompt)
-            return;
-
-        this._authPrompt = new AuthPrompt.AuthPrompt(this._gdmClient,
-            AuthPrompt.AuthPromptMode.UNLOCK_ONLY);
-        this._authPrompt.connect('failed', this._fail.bind(this));
-        this._authPrompt.connect('cancelled', this._fail.bind(this));
-        this._authPrompt.connect('reset', this._onReset.bind(this));
-
-        this._promptBox.add_child(this._authPrompt);
+        if (!this._authPrompt) {
+            this._authPrompt = new AuthPrompt.AuthPrompt(this._gdmClient,
+                AuthPrompt.AuthPromptMode.UNLOCK_ONLY);
+            this._authPrompt.connect('failed', this._fail.bind(this));
+            this._authPrompt.connect('cancelled', this._fail.bind(this));
+            this._authPrompt.connect('reset', this._onReset.bind(this));
+            this._promptBox.add_child(this._authPrompt);
+        }
 
-        this._authPrompt.reset();
-        this._authPrompt.updateSensitivity(true);
+        if (this._authPrompt.verificationStatus !== AuthPromptStatus.NOT_VERIFYING) {
+            this._authPrompt.reset();
+            this._authPrompt.updateSensitivity(true);
+        }
     }
 
     _maybeDestroyAuthPrompt() {
         let focus = global.stage.key_focus;
         if (focus === null ||
             (this._authPrompt && this._authPrompt.contains(focus)) ||
             (this._otherUserButton && focus === this._otherUserButton))
             this.grab_key_focus();
 
         if (this._authPrompt) {
             this._authPrompt.destroy();
             this._authPrompt = null;
         }
     }
 
     _showClock() {
         if (this._activePage === this._clock)
             return;
 
         this._activePage = this._clock;
 
         this._adjustment.ease(0, {
             duration: CROSSFADE_TIME,
             mode: Clutter.AnimationMode.EASE_OUT_QUAD,
             onComplete: () => this._maybeDestroyAuthPrompt(),
         });
     }
 
     _showPrompt() {
         this._ensureAuthPrompt();
-- 
2.31.1

